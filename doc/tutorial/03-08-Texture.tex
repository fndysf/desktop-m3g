\subsection{テクスチャー}

テクスチャーはTexuter2Dクラスで管理します。
ただし画像そのものはImage2Dクラスが扱います。
1Dテクスチャーおよび3DテクスチャーはM3Gではサポートしていません。
Texuter2DクラスのコンストラクタでImage2Dクラスのポインターを受け取ってインスタンス化します。
テクスチャー番号を指定してAppearanceクラスにセットします。
マルチテクスチャーの枚数の上限は実装依存です。
（クエリーの方法も書く）
M3Gではテクスチャー画像にjpegとpngが使用できます。
現在のDesktop-M3Gの実装ではpngのみサポートしています。
M3GではOpenGL2.1を要求しているのでテクスチャーサイズは2の階乗である必要はありません。
ただし一般的にはGPUは2の階乗のサイズの方が高速です。

\begin{verbatim}
Image2D* img = new Image2D (IMAGE::RGBA, image.png);
Texture2D* tex = new Texture2D (img);
app->setTexutre(0, tex);
\end{verbatim}

画像を後から差し替えるにはsetImage()メソッドを使います。

\begin{verbatim}
void 	setImage (Image2D *image)
\end{verbatim}

現在設定されている画像を取得するにはgetImage()メソッドを使います。

\begin{verbatim}
Image2D * 	getImage () const
\end{verbatim}

\subsubsection{テクスチャーフィルター}

setFiltering()メソッドでテクスチャーフィルターの選択を行います。
M3Gではミップマップは（GPUが対応していれば）常に有効です。

\begin{verbatim}
void 	setFiltering (int level_filter, int image_filter)
\end{verbatim}

第1引数のimage\_filterは画像内のフィルターをFILTER\_NEAREST, FILTER\_LINEARの中から選択します。
FILTER＿NEARESTは最近傍画素を、FILTER\_LINEARは周辺4画素を線形補間します。
第2引数のlevel\_filterはミップマップ階層間のフィルターを、FILTER\_BASE, FILTER\_NEAREST, FILTER\_LINEARの中から選択します。
FILTER\_BASEは常にミップマップレベル0の画像を使用します。
つまりミップマップ処理を行いません。

\begin{tabular}{llll}
  \rowcolor[gray]{0.8} & レベルフィルター & 画像フィルター & 説明 & 同等なOpenGL \\
  BASE\_LEVEL & NEAREST & ベースレベルをポイントサンプリング & NEAREST \\
  BASE\_LEVEL & LINEAR  & ベースレベルをバイリニアサンプリング & LINEAR \\
  NEAREST     & NEAREST & 1番近いミップマップレベルをポイントサンプリング & NEAREST\_MIPMAP\_NEAREST \\
  NEAREST     & LINEAR  & 1番近いミップマップレベルをバイリニアサンプリング & NEAREST\_MIPMAP\_NEAREST \\
  LINEAR      & NEAREST & 2つのミップマップレベルをポイントサンプリング & NEAREST\_MIPMAP\_LINEAR \\
  LINEAR      & LINEAR & 2つのミップマップレベルをバイリニアサンプリング & LINEAR\_MIPMAP\_LINEAR \\
\end{tabular}

現在のテクスチャーフィルターはgetImageFilter()メソッドとgetLevelFilter()メソッドを使って取得します。

\begin{verbatim}
int 	getImageFilter () const
int 	getLevelFilter () const
\end{verbatim}

\subsubsection{繰り返しモード}

setWrapping()メソッドでテクスチャーの範囲外アクセスの繰り返しモードを指定します。

\begin{verbatim}
void 	setWrapping (int wrap_s, int wrap_t)
\end{verbatim}

横(S)と縦(T)は個別に指定でき、それぞれWRAP\_CLAMP, WRAP\_REPEATから選択します。
WRAP\_CLAMPは最外周ピクセルにクランプされます。WRAP\_REPATは画像がタイル状に繰り返されます。

現在の繰り返しモードはgetWrappingS()メソッドとgetWrappingT()メソッドで取得できます。

\begin{verbatim}
int 	getWrappingS () const
int 	getWrappingT () const
\end{verbatim}

\subsubsection{ブレンディングモード}

setBlending()メソッドはテクスチャーカラーのブレンドの方法の制御方法を設定します。
現在RGBフォーマットおよびRGBAフォーマット以外の動作を確認していません。

\begin{verbatim}
void 	setBlending (int func)
\end{verbatim}

引数のfuncにはFUNC\_ADD, FUNC\_BLEND, FUNC\_DECAL, FUNC\_REPLACEの中から1つを選択します。

\begin{tabular}{ll}
  \rowcolor[gray]{0.8} & テクスチャーフォーマット & REPLACE & MODULATE & DECAL & BLEND & ADD \\
  ALPHA     & C_v = C_f & C_v = C_f     & 未定義 & C_v = C_f                 & C_v = C_f        \\
            & A_v = A_f & A_v = A_f     & 未定義 & A_v = A_f A_t             & A_v = A_f A_t \\

  LUMINANCE & C_v = C_t & C_v = C_f C_t & 未定義 & C_v = C_f (1-C_t) + C_c C_t & C_v = C_f + C_t \\
            & A_v = A_f & A_v = A_f     & 未定義 & A_v = A_f                  & A_v = A_f       \\

  LUM\_ALPHA & C_v = C_t & C_v = C_f C_t & 未定義 & C_v = C_f (1-C_t) + C_c C_t & C_v = C_f + C_t \\
            & A_v = A_f & A_v = A_f A_t  & 未定義 & A_v = A_f A_t              & A_v = A_f A_t     \\

  RGB       & C_v = C_t & C_v = C_f C_t & C_v = C_t & C_v = C_f (1-C_t) + C_c C_t & C_v = C_f + C_t \\
            & A_v = A_f & A_v = A_f     & A_v = A_f & A_v = A_f                  & A_v = A_f       \\

  RGBA      & C_v = C_t & C_v = C_f C_t & C_v = C_t & C_v = C_f (1-C_t) + C_c C_t & C_v = C_f + C_t \\
            & A_v = A_t & A_v = A_f A_t & A_v = A_f & A_v = A_f A_t               & A_v = A_f A_t      \\
\end{tabular}

現在のブレンディングモードはgetBlending()メソッドで取得します。

\begin{verbatim}
int 	getBlending () const
\end{verbatim}

\subsubsection{ブレンドカラー}

setBlendColor()メソッドはブレンディングモードFUNC\_BLENDで使用するブレンドカラーを設定します。
現在この機能は実装されていません。

\begin{verbatim}
void 	setBlendColor (int rgb)
\end{verbatim}

引数のブレンドカラーはRGBフォーマットで指定します。

\begin{verbatim}
   int rgb = (r << 16) | (g << 8) | (a << 0);
\end{verbatim}

現在のブレンドカラーはgetBlendColor()メソッドで取得できます。

\begin{verbatim}
int 	getBlendColor () const
\end{verbatim}

