
\subsection{ノード}

Nodeはシーンに存在する全てのオブジェクトの抽象基底クラスです。

オブジェクトにはCamera, Light, Group, World, Mesh, SkinnedMesh, MorphingMesh, Sprite3Dがあります。
これらはインスタンス化された後WorldクラスのaddChild()メソッドでシーンに追加されます。

このノードの親ノードはgetParent()メソッドで取得します。
親ノードはGroupもしくはWorldにaddChild()で追加されたときに自動的に設定されます。

\begin{verbatim}
    Node* getParent () const;
\end{verbatim}

親が居ない場合はNULLが返ります。

\subsubsection{スコープ}

ノードには”スコープ”が設定でき、シーンの階層構造に関係なくノードをグルーピングできます。
スコープはint型の整数値で、ビット演算のANDを取ったときに0以外の値が存在するときに同じグループと見なされます。

\[ scope_A \& scope_B != 0 \]

デフォルトは-1で、つまり全てのグループに所属します。
グループ設定は、可視性カリング(visibility culling)、ライティング(Lighting)、
ピッキング(pickig)に関係します。

スコープはsetScope()メソッドで設定します。

\begin{verbatim}
    void setScope (int scope);
\end{verbatim}

現在の設定されているスコープはgetScope()メソッドで取得します。

\begin{verbatim}
    int getScope () const;
\end{verbatim}


\subsubsection{ノードα}

ノードにはsetAlphaFactor()メソッドでα値を設定する事ができます。
α値はシーン階層を伝搬します。

\begin{verbatim}
    void setAlphaFactor (float alpha_factor);
\end{verbatim}

引数のalpha\_factorにはα値を[0,1]で指定します。
α=0に設定したノードは完全に不可視になります（レンダリングはされます）。
デフォルトはα=1です。

\subsubsection{レンダリングフラグ}

このノードがレンダリングされるかどうかをsetRenderingEnable()メソッドで設定します。

\begin{verbatim}
    void setRenderingEnable (bool enable);
\end{verbatim}

現在の設定はisRenderingEnabled()メソッドで取得します。

\begin{verbatim}
    bool isRenderingEnabled () const;
\end{verbatim}

\subsubsection{ピッキングフラグ}

シーンに仮想的なレイを飛ばして交差するノードを見つける事をピッキングと呼びます。
このノードがピッキング可能かどうかをsetPickingEnable()メソッドで設定します。
この機能は現在実装されていません。

\begin{verbatim}
    void setPickingEnable (bool enable);
\end{verbatim}

現在の設定はisPickingEnabled()メソッドで取得できます。

\begin{verbatim}
    bool isPickingEnabled () const;
\end{verbatim}


\subsubsection{アライメント}

ノードは他のノードに対して自動的に軸をそろえる事ができます。
これをアライメントと呼びます。アライメントは例えば
ビルボードやヘッドライト効果を実現するために使用します。
この機能は現在実装されていません。

アライメントはsetAlignmentTarget()メソッドで設定します。
この機能は現在実装されていません。

\begin{verbatim}
    void setAlignment (Node* z_ref, int z_target, Node* y_ref, int y_target);
\end{verbatim}

第1引数のz\_refにはZ軸のアライメント対象のノードを、
z\_targetにはターゲットをNONEもしくはORIGINを設定します。
NONEの場合はZ軸のアライメントはなく第1引数は無視されます。
ORIGINの場合はZ軸のアライメントを第1引数のノードに設定します。
同様に第3，第4引数はY軸に対するアライメントを設定します。
X軸に対する設定はありません。

現在のアライメント設定を取得するにはgetAlignmentReference()メソッドもしくは
getAlignmentTarget()メソッドを使用します。

アライメントターゲットを取得するにはgetAlignmentTarget()メソッドを使用します。

\begin{verbatim}
    int getAlignmentTarget (int axis) const;
\end{verbatim}

引数のaxisにはY\_AXISもしくはZ\_AXISを指定します。
指定した軸のアライメントターゲットが返ります。
NONEはアライメント無し、ORIGINはその軸はノードにアライメントしています。

アライメントの参照ノードはgetAlignmentReference()メソッドで取得します。

\begin{verbatim}
    Node* getAlignmentReference (int axis) const;
\end{verbatim}

引数のaxisにはY\_AXISもしくはZ\_AXISを指定します。
その軸がアライメントしている場合Nodeが返ります。
アライメントしていない（ターゲットがNONEの）場合はNULLが返ります。

アライメントの設定をした後にalign()メソッドを呼ぶと、アライメントがそろいます。

\begin{verbatim}
    void align (Node* reference);
\end{verbatim}

引数referenceは設定されていない軸に対するアライメントを使用したい場合に指定します。
これは動的にアライメントをそろえるために使用されます。




\subsubsection{ノードトランスフォーム}

このノードから指定されたノードへの座標変換行列を取得できます。
それにはgetTransformTo()メソッドを使います。

\begin{verbatim}
    bool getTransformTo (Node* target, Transform* transform) const;
\end{verbatim}

第1引数には変換先のノードを、第2引数には結果を書き込むTransformオブジェクトを指定します。
戻り値は変換行列が計算できた場合はtrue, 計算できない場合はfalseが返ります。











