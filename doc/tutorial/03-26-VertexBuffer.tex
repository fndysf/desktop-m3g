\subsection {バーテックスバッファー}

VertexBufferクラスは頂点座標、法線、テクスチャー座標、頂点カラーなどを保持・管理するクラスです。
それらのデータを保持するためにVertexArrayクラスをメンバーに持ちます。
通常Meshクラスのコンストラクタで渡します。

\begin{verbatim}
    VerteBuffer* vbuf = new VertexBuffer;
    Mesh* mesh = new Mesh (vbuf, index, appearance);
\end{verbatim}


\subsubsection{頂点座標}

VertexBufferに頂点座標をセットするにはsetPositions()メソッドを使います。

\begin{verbatim}
    void setPositions (VertexArray* positios, float scale, float* bias);
\end{verbatim}

第1引数には頂点座標として使うデータの入ったVertexArrayオブジェクトを渡します。
コンポーネント数は3です。
第2，第3引数にはスケール乗数(scale)とバイアス値(bias)を渡します。
バーテックスアレイ内の値をvとすれば最終的な値は以下の式で計算されます。

\[ v' = scale * v + bias \]


頂点座標として使用しているVertexArrayオブジェクトを取得するにはgetPositions()メソッドを使います。

\begin{verbatim}
    VertexArray* getPositions (float* scale_bias) const;
\end{verbatim}

引数には

\subsubsection{法線}

VertexBufferに法線をセットするにはsetNormals()メソッドを使います。

\begin{verbatim}
    void setNormals (VertexArray* normals);
\end{verbatim}

第1引数には法線として使うデータの入ったVertexArrayオブジェクトを渡します。
コンポーネント数は3です。
スケールとバイアスは固定でcharとshort型が表現できる全領域が[-1,1]にマップされます。
すなわちデータがchar型の場合$ scale=2/255 \, bias=1/255 $で、
short型の場合は$ scale=2/65535 \, bias=1/65535 $に自動的にセットされます。

法線として使用しているVertexArrayオブジェクトを取得するにはgetNormals()メソッドを使います。

\begin{verbatim}
    VertexArray* getNormals () const;
\end{verbatim}


\subsubsection{テクスチャー座標}

VertexBufferにテクスチャー座標をセットするにはsetTexCoords()メソッドを使います。

\begin{verbatim}
    void setTexCoords (int index, VertexArray* tex_coords, float scale, float* bias);
\end{verbatim}

第1引数にはテクスチャー番号、第2引数にはテクスチャー座標として使うデータの入ったVertexArrayオブジェクトを渡します。
コンポーネント数は1または2です。コンポーネントサイズは1または2です。
第3，第4引数にはスケール乗数(scale)とバイアス値(bias)を渡します。
計算式は同じです。
テクスチャー番号は0から始まる整数値で使用中のGPUが対応しているマルチテクスチャーの枚数-1まで指定できます。

\begin{verbatim}
    VertexArray* getTexCoords (int index, float* scale_bias) const;
\end{verbatim}

現時のテクスチャー座標を取得するにはgetTexCoords()メソッドを使います。

\begin{verbatim}
    VertexArray* getTexCoords (int index, float* scale_bias) const;
\end{verbatim}

第1引数にはテクスチャー番号を指定します。第2引数にはfloat2個分のメモリ領域を指すポインターを渡します。
スケール値とバイアス値がこの順で書き込まれます。


\subsubsection{頂点カラー}

VertexBufferに頂点カラーを設定するにはsetColors()メソッドを使います。

\begin{verbatim}
    void setColors (VertexArray* colors);
\end{verbatim}

第1引数には法線として使うデータの入ったVertexArrayオブジェクトを渡します。
コンポーネント数は3です。コンポーネントサイズは1です。
スケールとバイアスは固定でchar型が表現できる全領域が[0,1]にマップされます。
すなわち$ scale=1/255 \, bias=128/255 $に自動的にセットされます。

現在の頂点カラー配列を取得するにはgetColors()メソッドを使います。

\begin{verbatim}
    VertexArray* getColors () const;
\end{verbatim}

全頂点を同一カラーに設定する場合setDefaultColor()メソッドが使えます。
両方指定した場合はsetColors()メソッドで指定した方が優先されます。

\begin{verbatim}
    void setDefaultColor (int rgb);
\end{verbatim}

引数の色にはrgbフォーマットで指定します。

\begin{verbatim}
    int rgb = (r << 16) | (r << 8) | (b << 0);
\end{verbatim}

M3Gの仕様では頂点カラーが使われるにはMaterialクラスの頂点カラートラッキングが有効になっている必要があります。
ただし現在の実装では頂点カラートラッキングの値にかかわらず、VertexBufferに頂点カラーがセットされていれば使用されます。

現在のデフォルトの頂点カラーを取得するにはgetDefaultColor()メソッドを使います。

\begin{verbatim}
    int getDefaultColor () const;
\end{verbatim}








